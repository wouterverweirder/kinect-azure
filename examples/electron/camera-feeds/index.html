<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Kinect Azure Example</title>
    <style>
      body {
        display: grid;
        grid-template-columns: 50% 50%;
      }
      img, canvas {
        width: 100%;
        height: auto;
      }
    </style>
  </head>
  <body>
    <img id="colorImage"></img>
    <canvas id="depthCanvas"></canvas>
    <script>
      {
        const KinectAzure = require('kinect-azure');
        const kinect = new KinectAzure();
        const $colorImage = document.getElementById('colorImage');

        const $depthCanvas = document.getElementById('depthCanvas'),
          depthCtx = $depthCanvas.getContext('2d');
        let depthImageData, depthModeRange;

        const init = () => {
          startKinect();
        };

        const startKinect = () => {
          if(kinect.open()) {
            const depthMode = KinectAzure.K4A_DEPTH_MODE_NFOV_UNBINNED;
            kinect.startCameras({
              depth_mode: depthMode,
              color_resolution: KinectAzure.K4A_COLOR_RESOLUTION_720P,
              camera_fps: KinectAzure.K4A_FRAMES_PER_SECOND_15
            });
            depthModeRange = kinect.getDepthModeRange(depthMode);
            let colorImageURL;

            kinect.startListening((data) => {
              // depth
              {
                if (!depthImageData && data.depthImageFrame.width > 0) {
                  $depthCanvas.width = data.depthImageFrame.width;
                  $depthCanvas.height = data.depthImageFrame.height;
                  depthImageData = depthCtx.createImageData($depthCanvas.width, $depthCanvas.height);
                }
                if (depthImageData) {
                  renderDepthFrameAsBlueToRed(data);
                }
              }

              // color - default jpg stream
              const bufferCopy = Buffer.from(data.colorImageFrame.imageData);
              // setting a data url leaks memory - Blobs seem to work fine
              // https://stackoverflow.com/questions/19298393/setting-img-src-to-dataurl-leaks-memory
              const imageBlob = new Blob([bufferCopy], { type: 'image/jpeg'});
              if (colorImageURL) {
                URL.revokeObjectURL(colorImageURL);
              }
              colorImageURL = URL.createObjectURL(imageBlob);
              $colorImage.src = colorImageURL;
            });
          }
        };

        const renderDepthFrameAsGreyScale = (data) => {
          const newPixelData = Buffer.from(data.depthImageFrame.imageData);
          const pixelArray = depthImageData.data;
          let depthPixelIndex = 0;
          for (let i = 0; i < depthImageData.data.length; i+=4) {
            const depthValue = newPixelData[depthPixelIndex+1] << 8 | newPixelData[depthPixelIndex];
            const normalizedValue = map(depthValue, depthModeRange.min, depthModeRange.max, 255, 0);
            pixelArray[i] = normalizedValue;
            pixelArray[i+1] = normalizedValue;
            pixelArray[i+2] = normalizedValue;
            pixelArray[i+3] = 0xff;
            depthPixelIndex += 2;
          }
          depthCtx.putImageData(depthImageData, 0, 0);
        };

        const renderDepthFrameAsBlueToRed = (data) => {
          const newPixelData = Buffer.from(data.depthImageFrame.imageData);
          const pixelArray = depthImageData.data;
          let depthPixelIndex = 0;
          const range = 2 / 3;

          for (let i = 0; i < depthImageData.data.length; i+=4) {
            const depthValue = Math.min(depthModeRange.max, Math.max(depthModeRange.min, newPixelData[depthPixelIndex+1] << 8 | newPixelData[depthPixelIndex]));
            let hue = map(depthValue, depthModeRange.min, depthModeRange.max, 0, 1);
            hue *= range;
            hue = range - hue;
            const rgb = hsvToRgb(hue, 1, 1);

            pixelArray[i] = rgb[0];
            pixelArray[i+1] = rgb[1];
            pixelArray[i+2] = rgb[2];
            pixelArray[i+3] = 0xff;
            depthPixelIndex += 2;
          }
          depthCtx.putImageData(depthImageData, 0, 0);
        };

        const map = (value, inputMin, inputMax, outputMin, outputMax) => {
          return (value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin) + outputMin;
        };

        /**
         * https://gist.github.com/mjackson/5311256
         * Converts an HSV color value to RGB. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
         * Assumes h, s, and v are contained in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         *
         * @param   Number  h       The hue
         * @param   Number  s       The saturation
         * @param   Number  v       The value
         * @return  Array           The RGB representation
         */
        const hsvToRgb = (h, s, v) => {
          let r, g, b;

          const i = Math.floor(h * 6);
          const f = h * 6 - i;
          const p = v * (1 - s);
          const q = v * (1 - f * s);
          const t = v * (1 - (1 - f) * s);

          switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
          }

          return [ r * 255, g * 255, b * 255 ];
        }

        init();
      }
    </script>
  </body>
</html>
